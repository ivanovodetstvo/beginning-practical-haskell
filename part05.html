<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Part 6: Ugly code</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="css/buttondown.css" type="text/css" />
  <meta name="author" content="Richard Cook"/>
  <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"></script>
  <script src="js/main.js"></script>
</head>
<body>
<nav>
  <a href=".">Home</a> |
  <a href="part01.html">Introduction</a> |
  <a href="part02.html">Functions</a> |
  <a href="part03.html">Types</a> |
  <a href="part04.html">I/O</a> |
  <a href="part05.html">Ugly code</a> |
  <a href="part06.html">Other</a> |
  <a href="q-and-a.html">Q&amp;A</a> |
  <a href="https://github.com/rcook/beginning-practical-haskell/issues">Found a bug?</a>
</nav>
<div id="header">
<h1 class="title">Part 6: Ugly code</h1>
</div>
<blockquote>
<p><strong><em>TO DO</em></strong></p>
<ul>
<li>Evaluating the definition of an action doesn't cause the action to happen, rather it builds up a structure potentially combining other I/O actions that, conceptually at least, are performed outside the expression evaluation. See https://www.haskell.org/tutorial/io.html</li>
</ul>
</blockquote>
<p>Let's look at a more complicated example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">readInteger ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
readInteger <span class="fu">=</span> read

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStr <span class="st">&quot;Enter x: &quot;</span>
    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> hFlush stdout
    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> getLine
    <span class="fu">&gt;&gt;=</span> \xStr <span class="ot">-&gt;</span> putStr <span class="st">&quot;Enter y: &quot;</span>
    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> hFlush stdout
    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> getLine
    <span class="fu">&gt;&gt;=</span> \yStr <span class="ot">-&gt;</span>
        <span class="kw">let</span> x <span class="fu">=</span> readInteger xStr
            y <span class="fu">=</span> readInteger yStr
            z <span class="fu">=</span> x <span class="fu">+</span> y
        <span class="kw">in</span> putStrLn <span class="fu">$</span> <span class="st">&quot;z = &quot;</span> <span class="fu">++</span> show z</code></pre></div>
<p>This program displays a prompt and reads in a line of input twice. It then converts each of the two lines into an <code>Integer</code>, computes their sum and then writes the output to the terminal. This builds on what we've already seen. We've introduced the <code>++</code> operator, pronounced &quot;append&quot;. This joins two lists together; <code>String</code> is <code>[Char]</code>, so this joins two strings together.</p>
<p>I told you that Haskell had clean, minimal syntax. You've seen nearly everything here. However, this does not look pleasant. Let's try to do something about that. First, let's reflow the code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">readInteger ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
readInteger <span class="fu">=</span> read

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
    putStr <span class="st">&quot;Enter x: &quot;</span> <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
    hFlush stdout <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
    getLine <span class="fu">&gt;&gt;=</span> \xStr <span class="ot">-&gt;</span>
    putStr <span class="st">&quot;Enter y: &quot;</span> <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
    hFlush stdout <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
    getLine <span class="fu">&gt;&gt;=</span> \yStr <span class="ot">-&gt;</span>
    <span class="kw">let</span> x <span class="fu">=</span> readInteger xStr
        y <span class="fu">=</span> readInteger yStr
        z <span class="fu">=</span> x <span class="fu">+</span> y
    <span class="kw">in</span>
    putStrLn <span class="fu">$</span> <span class="st">&quot;z = &quot;</span> <span class="fu">++</span> show z</code></pre></div>
<p>That's marginally better. There's still a proliferation of <code>&gt;&gt;=</code> operators and lambdas. What next? Let's take a look at another method provided by <code>Monad</code>, namely <code>&gt;&gt;</code>, pronounced &quot;then&quot;. This is the second &quot;monadic sequencing operator&quot; with the following type signature:</p>
<pre class="ghci"><code>Î»&gt; :t (&gt;&gt;)
(&gt;&gt;) :: Monad m =&gt; m a -&gt; m b -&gt; m b</code></pre>
<p>This is a simpler version of <code>&gt;&gt;=</code> which can be used when the value returned by the previous action is to be ignored. In this program, we twice use <code>putStr</code> followed by <code>hFlush</code> and <code>getLine</code> which both ignore the value yielded by the preceding action using <code>_</code>. We can, therefore, rewrite the program as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">readInteger ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
readInteger <span class="fu">=</span> read

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
    putStr <span class="st">&quot;Enter x: &quot;</span> <span class="fu">&gt;&gt;</span>
    hFlush stdout <span class="fu">&gt;&gt;</span>
    getLine <span class="fu">&gt;&gt;=</span> \xStr <span class="ot">-&gt;</span>
    putStr <span class="st">&quot;Enter y: &quot;</span> <span class="fu">&gt;&gt;</span>
    hFlush stdout <span class="fu">&gt;&gt;</span>
    getLine <span class="fu">&gt;&gt;=</span> \yStr <span class="ot">-&gt;</span>
    <span class="kw">let</span> x <span class="fu">=</span> readInteger xStr
        y <span class="fu">=</span> readInteger yStr
        z <span class="fu">=</span> x <span class="fu">+</span> y
    <span class="kw">in</span>
    putStrLn <span class="fu">$</span> <span class="st">&quot;z = &quot;</span> <span class="fu">++</span> show z</code></pre></div>
<p>That's another step in the right direction.</p>
<p>This code shape is so common, however, that Haskell introduces special syntax to make it even cleaner. This is known as <code>do</code>-notation named after the <code>do</code>-keyword used to introduce it.</p>
<p>Consider:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> action1
   action2
   action3</code></pre></div>
<p>This is transformed or <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">desugared</a> to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;</span>
<span class="kw">do</span> action2
   action3</code></pre></div>
<p>And then to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;</span>
action2 <span class="fu">&gt;&gt;</span>
<span class="kw">do</span> action3</code></pre></div>
<p>And, finally, to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;</span>
action2 <span class="fu">&gt;&gt;</span>
action3</code></pre></div>
<p>The second form that can be included in <code>do</code>-notation includes a binding of the action's result to a name:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> x1 <span class="ot">&lt;-</span> action1
   x2 <span class="ot">&lt;-</span> action2
   action3 x1 x2</code></pre></div>
<p>becomes</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span>
<span class="kw">do</span> x2 <span class="ot">&lt;-</span> action2
   action3 x1 x2</code></pre></div>
<p>becomes</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span>
action2 <span class="fu">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span>
<span class="kw">do</span> action3 x1 x2</code></pre></div>
<p>becomes</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span>
action2 <span class="fu">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span>
action3 x1 x2</code></pre></div>
<p>Furthermore, these two forms can be combined. With this new knowledge, we can rewrite our original program as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">readInteger ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
readInteger <span class="fu">=</span> read

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    putStr <span class="st">&quot;Enter x: &quot;</span>
    hFlush stdout
    xStr <span class="ot">&lt;-</span> getLine
    putStr <span class="st">&quot;Enter y: &quot;</span>
    hFlush stdout
    yStr <span class="ot">&lt;-</span> getLine
    <span class="kw">let</span> x <span class="fu">=</span> readInteger xStr
        y <span class="fu">=</span> readInteger yStr
        z <span class="fu">=</span> x <span class="fu">+</span> y
    putStrLn <span class="fu">$</span> <span class="st">&quot;z = &quot;</span> <span class="fu">++</span> show z</code></pre></div>
<p>Inside <code>do</code>-notation, Haskell also drops the <code>in</code> from let-bindings.</p>
<p>What we have left is something that looks suspiciously like a regular, old &quot;imperative&quot; program but with fewer parentheses. Make no mistake, however: this is still program consisting of a <code>main</code> function that is the evaluation of a single expression. This all comes down to the guarantees of referential transparency we get from pure functions. Though it looks like a series of statements, this program is desugared to a series of expressions employing the <code>&gt;&gt;</code> and <code>&gt;&gt;=</code> operators. In the case of <code>IO</code>'s implementation of these operators, we have functional dependencies between producers and consumers of <code>IO</code>-wrapped values. These subexpressions are, therefore, guaranteed to not be reordered: the resulting code will execute in the expected order. Only subexpressions that do not have such functional dependencies will be amenable to interleaving since the reordering of such evaluation cannot be detected by external observers.</p>
<hr/>
<footer style="font-size: small; text-align: right;">
  Copyright &copy; 2016&ndash;2017, Richard Cook<br/>
  <a href="https://github.com/rcook/beginning-practical-haskell/">Source code on GitHub</a>
</footer>
</body>
</html>
