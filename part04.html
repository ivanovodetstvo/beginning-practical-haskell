<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Part 4: I/O</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="css/buttondown.css" type="text/css" />
  <meta name="author" content="Richard Cook"/>
  <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"></script>
  <script src="js/main.js"></script>
</head>
<body>
<nav>
  <a href=".">Home</a> |
  <a href="part01.html">Introduction</a> |
  <a href="part02.html">Functions</a> |
  <a href="part03.html">Types</a> |
  <a href="part04.html">I/O</a> |
  <a href="part05.html">Ugly code</a> |
  <a href="part06.html">Other</a> |
  <a href="q-and-a.html">Q&amp;A</a> |
  <a href="https://github.com/rcook/beginning-practical-haskell/issues">Found a bug?</a>
</nav>
<div id="header">
<h1 class="title">Part 4: I/O</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#the-prelude"><span class="toc-section-number">1</span> The Prelude</a><ul>
<li><a href="#the-print-function"><span class="toc-section-number">1.1</span> The <code>print</code> function</a></li>
<li><a href="#a.k.a.-bind"><span class="toc-section-number">1.2</span> <code>&gt;&gt;=</code> a.k.a. &quot;bind&quot;</a></li>
<li><a href="#the-read-function"><span class="toc-section-number">1.3</span> The <code>read</code> function</a></li>
<li><a href="#the-getline-function"><span class="toc-section-number">1.4</span> The <code>getLine</code> function</a></li>
<li><a href="#the-putstr-function"><span class="toc-section-number">1.5</span> The <code>putStr</code> function</a></li>
<li><a href="#the-hflush-function"><span class="toc-section-number">1.6</span> The <code>hFlush</code> function</a></li>
<li><a href="#combine-them-all"><span class="toc-section-number">1.7</span> Combine them all</a></li>
<li><a href="#wait-a-minute"><span class="toc-section-number">1.8</span> Wait a minute!</a></li>
</ul></li>
</ul>
</div>
<p>Given the title of this course, I'll assume you came here to learn how to write useful programs. Practical programs typically need to interact with the outside world. In the absence of input/output, all your programs can do is warm up your CPU.</p>
<p>Most other programming languages allow subroutines to directly perform arbitrary input and output or interaction with the outside world. However, this is fundamentally incompatible with a language such as Haskell which maintains a strong correspondence between its functions and mathematical functions.</p>
<p>Mathematical functions:</p>
<ul>
<li>Cannot read files from disc or write to the screen</li>
<li>Cannot read or mutate global state</li>
<li>Can only return values that are functions of their arguments or other pure functions</li>
</ul>
<p>Fortunately, there are several different solutions to this problem. Modern Haskell's approach makes use of an abstract <code>IO</code> type. The model is functionally equivalent to the continuation-passing style, though few people actually explicitly use this particular terminology. We'll build up step-by-step to full-blown I/O.</p>
<h1 id="the-prelude"><span class="header-section-number">1</span> The Prelude</h1>
<p>Haskell's prelude is a module provided by the implementation that defines many standard functions. It is implicitly imported into every Haskell source file, unless this is explicitly disabled. We'll use a few functions from <code>Prelude</code> to explore I/O.</p>
<p>Our mission is to read a number in from the user, do something to it and then output the result to the terminal.</p>
<h2 id="the-print-function"><span class="header-section-number">1.1</span> The <code>print</code> function</h2>
<p>We've already seen this function, but now we'll look at in a little more detail:</p>
<pre class="ghci"><code>λ&gt; :t print
print :: Show a =&gt; a -&gt; IO ()</code></pre>
<p>The type signature has a type constraint of <code>Show a</code> where <code>a</code> is a type variable again. For the sake of this discussion, <code>Show</code> is a type class with a single &quot;method&quot; <code>show</code> (it's not quite this simple but, whatever!):</p>
<pre class="ghci"><code>λ&gt; :t show
show :: Show a =&gt; a -&gt; String</code></pre>
<p>A function on a type class is commonly referred to as a &quot;method&quot; by analogy with methods on a class or interface in object-oriented languages. Thus, <code>show</code> is a method taking a value of some type <code>a</code> and returning a <code>String</code>. All of Haskell's primitive types implement <code>Show</code> which typically return a human-readable representation of a value. You can provide instances for user-defined types—which we'll discuss eventually—or have them derived automatically for you using <code>deriving Show</code> where possible.</p>
<p>So, what's <code>IO</code>? Well, it's a type class much like <code>Num</code> and we already saw <code>()</code> or the unit type. Therefore, this is a function that takes something of type <code>a</code> in the type (subject to the <code>Show a</code> constraint) and returns <code>IO ()</code></p>
<h2 id="a.k.a.-bind"><span class="header-section-number">1.2</span> <code>&gt;&gt;=</code> a.k.a. &quot;bind&quot;</h2>
<p>Here are more details of <code>IO</code> in GHCi:</p>
<pre class="ghci"><code>λ&gt; :i IO
newtype IO a
  = ghc-prim-0.5.0.0:GHC.Types.IO (ghc-prim-0.5.0.0:GHC.Prim.State#
                                     ghc-prim-0.5.0.0:GHC.Prim.RealWorld
                                   -&gt; (# ghc-prim-0.5.0.0:GHC.Prim.State#
                                           ghc-prim-0.5.0.0:GHC.Prim.RealWorld,
                                         a #))
    -- Defined in ‘ghc-prim-0.5.0.0:GHC.Types’
instance Monad IO -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Applicative IO -- Defined in ‘GHC.Base’
instance Monoid a =&gt; Monoid (IO a) -- Defined in ‘GHC.Base’</code></pre>
<p>This tells us that <code>IO</code> has instances for four other type classes, namely <code>Monad</code>, <code>Functor</code>, <code>Applicative</code> and <code>Monoid</code>. Let's look at <code>Monad</code>:</p>
<pre class="ghci"><code>λ&gt; :i Monad
class Applicative m =&gt; Monad (m :: * -&gt; *) where
  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
  (&gt;&gt;) :: m a -&gt; m b -&gt; m b
  return :: a -&gt; m a
  fail :: String -&gt; m a
  {-# MINIMAL (&gt;&gt;=) #-}
    -- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((-&gt;) r) -- Defined in ‘GHC.Base’</code></pre>
<p>Since <code>IO</code> has an instance for <code>Monad</code>, it provides an implementation of method <code>&gt;&gt;=</code>, pronounced &quot;bind&quot;:</p>
<pre class="ghci"><code>λ&gt; :t (&gt;&gt;=)
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code></pre>
<p>Note that functions with special symbols in their names will, under certain circumstances, require surrounding parentheses both in GHCi and Haskell source code.</p>
<p>Specializing from <code>Monad</code> to <code>IO</code>, <code>&gt;&gt;=</code> is a function that takes <code>IO a</code>, where <code>a</code> is a type variable, a function from <code>a</code> to <code>IO b</code> and evaluates to an <code>IO b</code>. We can try out <code>print</code> by itself:</p>
<pre class="ghci"><code>λ&gt; print 5
5
λ&gt; :t print 5
print 5 :: IO ()
λ&gt; print &quot;hello&quot;
&quot;hello&quot;
λ&gt; :t print &quot;hello&quot;
print &quot;hello&quot; :: IO ()</code></pre>
<p>Note that <code>print 5</code> and <code>print &quot;hello&quot;</code> are two separate statements in GHCi. In &quot;full&quot; Haskell in a source file, programs must consist of a single expression. Let's see if we can combine them into a single expression using <code>&gt;&gt;=</code>.</p>
<p>Given an <code>IO ()</code>, we need a function that takes unit and returns <code>IO b</code> where <code>b</code> can be unit too. We can build such a function that ignores its first argument and evaluates to <code>print &quot;hello&quot;</code>. We'll call it <code>f</code> for now:</p>
<pre class="ghci"><code>λ&gt; f :: () -&gt; IO (); f _ = print &quot;hello&quot;</code></pre>
<p>We can then combine it with <code>print 5</code> by passing it as the second operand to <code>&gt;&gt;=</code>:</p>
<pre class="ghci"><code>λ&gt; print 5 &gt;&gt;= f
5
&quot;hello&quot;</code></pre>
<p>Our function <code>f</code> is great. However, we use it exactly once and should, therefore, never need to refer to it by name. So, let's use a lambda instead. Let's start by defining a alternative version of <code>f</code>, named <code>f'</code>, to which we'll assign the equivalent anonymous function:</p>
<pre class="ghci"><code>λ&gt; f&#39; :: () -&gt; IO (); f&#39; = \_ -&gt; print &quot;hello&quot;</code></pre>
<p>Function <code>f'</code> is semantically identical to <code>f</code> and, so, we can write:</p>
<pre class="ghci"><code>λ&gt; print 5 &gt;&gt;= f&#39;
5
&quot;hello&quot;</code></pre>
<p>Since <code>f'</code> is referentially transparent, we can replace it with its value instead:</p>
<pre class="ghci"><code>λ&gt; print 5 &gt;&gt;= \_ -&gt; print &quot;hello&quot;
5
&quot;hello&quot;
λ&gt; :t print 5 &gt;&gt;= \_ -&gt; print &quot;hello&quot;
print 5 &gt;&gt;= \_ -&gt; print &quot;hello&quot; :: IO ()</code></pre>
<p>Now we have single expression whose type is <code>IO ()</code> with no unnecessary names. We can then put this in a source file:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="dv">5</span> <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> print <span class="st">&quot;hello&quot;</span></code></pre></div>
<p>And compile and run as follows:</p>
<pre class="console"><code>&gt; stack runhaskell Scratch.hs
5
&quot;hello&quot;</code></pre>
<p>We have successfully demonstrated several functionally equivalent ways of using a functional dependency to provide an explicit ordering of execution.</p>
<h2 id="the-read-function"><span class="header-section-number">1.3</span> The <code>read</code> function</h2>
<p>Let's do some more exploring using GHCi:</p>
<pre class="ghci"><code>λ&gt; :t read
read :: Read a =&gt; String -&gt; a</code></pre>
<p>This takes <code>String</code> and returns <code>a</code> which is subject to the <code>Read a</code> constraint. <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Read.html"><code>Read</code></a> is a type class that supports reading a value from a <code>String</code>. Haskell's primitive types have instances of <code>Read</code>. Since this is function is polymorphic in its return type, we'll need a type annotation to choose a specific instance of it:</p>
<pre class="ghci"><code>λ&gt; :t read :: String -&gt; Integer
read :: String -&gt; Integer :: String -&gt; Integer</code></pre>
<p>This is a function that takes <code>String</code> and returns an <code>Integer</code>. We can assign a (monomorphic) name to this specific instance of <code>read</code> and test it out:</p>
<pre class="ghci"><code>λ&gt; readInteger :: String -&gt; Integer; readInteger = read
λ&gt; :t readInteger
readInteger :: String -&gt; Integer
λ&gt; readInteger &quot;123&quot;
123</code></pre>
<h2 id="the-getline-function"><span class="header-section-number">1.4</span> The <code>getLine</code> function</h2>
<p>Here's <code>getline</code> in all its glory:</p>
<pre class="ghci"><code>λ&gt; :t getLine
getLine :: IO String</code></pre>
<h2 id="the-putstr-function"><span class="header-section-number">1.5</span> The <code>putStr</code> function</h2>
<p>This one is straightforward:</p>
<pre class="ghci"><code>λ&gt; :t putStr
putStr :: String -&gt; IO ()</code></pre>
<p>This is simply <code>putStrLn</code> without the extra line ending.</p>
<h2 id="the-hflush-function"><span class="header-section-number">1.6</span> The <code>hFlush</code> function</h2>
<p>By itself, <code>putStr</code> outputs the given characters to the standard output stream on the terminal but does not, by default, flush the stream. Just like using standard output from a C program, we'll need to flush the buffer prior to requesting input from the user. In C/C++ we'd have to do the following:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">printf(<span class="st">&quot;Buffered output: &quot;</span>);
fflush(stdout);</code></pre></div>
<p>Similarly, in Haskell we'll need to use <code>hFlush</code>:</p>
<pre class="ghci"><code>λ&gt; :t hFlush
hFlush :: Handle -&gt; IO ()</code></pre>
<p>The handle itself, <code>stdout</code>, is in the <code>System.IO</code> namespace, so you'll need to import this namespace. This is our first use of the <code>import</code> keyword in Haskell which we'll run into more in the future:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span></code></pre></div>
<h2 id="combine-them-all"><span class="header-section-number">1.7</span> Combine them all</h2>
<p>This is what we're going to do: * Print a prompt to the terminal (using <code>putStr</code>) * Flush the standard output buffer (using <code>hFlush</code>) * Get a string from the keyboard (using <code>getLine</code>) * Convert the string to an integer (using <code>read</code>/<code>readInteger</code>) * Multiply the integer by 2 (using <code>*</code>) * Print out the result (using <code>print</code>)</p>
<p>The resulting program will consist of a <code>main</code> function itself consisting of a single expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">readInteger ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
readInteger <span class="fu">=</span> read

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStr <span class="st">&quot;Enter a number and I&#39;ll double it: &quot;</span>
    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> hFlush stdout
    <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> getLine
    <span class="fu">&gt;&gt;=</span> \l <span class="ot">-&gt;</span> print (<span class="dv">2</span> <span class="fu">*</span> readInteger l)</code></pre></div>
<p>Let's run it:</p>
<pre class="console"><code>&gt; stack runhaskell Scratch.hs
Enter a number and I&#39;ll double it: 5
10</code></pre>
<h2 id="wait-a-minute"><span class="header-section-number">1.8</span> Wait a minute!</h2>
<p>But, didn't you say that Haskell was purely functional? Surely, <code>putStr</code>, <code>getLine</code> and <code>print</code> have side effects?</p>
<p>Well, no, not at all:</p>
<ul>
<li>They're &quot;actions&quot;</li>
<li>They're strung together using <code>&gt;&gt;=</code></li>
<li>At no point do they mutate global state or interact with the outside world</li>
<li>We build up an expression tree or graph of these actions</li>
<li>They are &quot;executed&quot; when the program is run</li>
</ul>
<p>Did you mention something about continuation passing?</p>
<ul>
<li>Why, yes, I did!</li>
<li>That's what <code>&gt;&gt;=</code> is doing</li>
<li>You provide an action as its first argument</li>
<li>And the continuation as the second argument</li>
<li>This second argument is the thing that is to be evaluated after the first action has run at program execution time: the value generated by the first action is passed as an argument to the continuation</li>
</ul>
<p><code>&gt;&gt;=</code> is great as it provides the ability to sequence actions (at least when it's used with <code>IO</code>). However, all of these <code>&gt;&gt;=</code>s will become ugly as we sequence more and more subexpressions in our program. We will talk about how to clean this up soon.</p>
<hr/>
<footer style="font-size: small; text-align: right;">
  Copyright &copy; 2016&ndash;2017, Richard Cook<br/>
  <a href="https://github.com/rcook/beginning-practical-haskell/">Source code on GitHub</a>
</footer>
</body>
</html>
