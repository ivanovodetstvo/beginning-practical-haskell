<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Part 1: Introduction</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="css/buttondown.css" type="text/css" />
  <meta name="author" content="Richard Cook"/>
  <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"></script>
  <script src="js/main.js"></script>
</head>
<body>
<nav>
  <a href=".">Home</a> |
  <a href="part01.html">Introduction</a> |
  <a href="part02.html">Functions</a> |
  <a href="part03.html">Types</a> |
  <a href="part04.html">I/O</a> |
  <a href="part05.html">Ugly code</a> |
  <a href="part06.html">Other</a> |
  <a href="q-and-a.html">Q&amp;A</a> |
  <a href="https://github.com/rcook/beginning-practical-haskell/issues">Found a bug?</a>
</nav>
<div id="header">
<h1 class="title">Part 1: Introduction</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#what-is-haskell"><span class="toc-section-number">1</span> What is Haskell?</a><ul>
<li><a href="#purely-functional-programming-language"><span class="toc-section-number">1.1</span> Purely functional programming language</a></li>
<li><a href="#non-strictness"><span class="toc-section-number">1.2</span> Non-strictness</a></li>
<li><a href="#static-typing"><span class="toc-section-number">1.3</span> Static typing</a></li>
<li><a href="#call-by-need"><span class="toc-section-number">1.4</span> Call-by-need</a></li>
<li><a href="#whitespace-sensitive-syntax"><span class="toc-section-number">1.5</span> Whitespace-sensitive syntax</a></li>
<li><a href="#garbage-collection"><span class="toc-section-number">1.6</span> Garbage collection</a></li>
<li><a href="#naming-conventions"><span class="toc-section-number">1.7</span> Naming conventions</a></li>
<li><a href="#what-else"><span class="toc-section-number">1.8</span> What else?</a></li>
</ul></li>
<li><a href="#our-first-haskell-code"><span class="toc-section-number">2</span> Our first Haskell code</a><ul>
<li><a href="#interactive-haskell"><span class="toc-section-number">2.1</span> Interactive Haskell</a></li>
<li><a href="#your-first-haskell-source-file"><span class="toc-section-number">2.2</span> Your first Haskell source file</a></li>
<li><a href="#differences-between-ghc-and-ghci"><span class="toc-section-number">2.3</span> Differences between GHC and GHCi</a></li>
</ul></li>
<li><a href="#a-more-realistic-example"><span class="toc-section-number">3</span> A more realistic example</a><ul>
<li><a href="#when-to-use-type-annotations"><span class="toc-section-number">3.1</span> When to use type annotations</a></li>
</ul></li>
</ul>
</div>
<h1 id="what-is-haskell"><span class="header-section-number">1</span> What is Haskell?</h1>
<p><em>[Sources: <a href="https://wiki.haskell.org/Functional_programming">1</a>, <a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">2</a>, <a href="http://dev.stephendiehl.com/fun/005_evaluation.html">3</a>]</em></p>
<ul>
<li>Purely functional programming language</li>
<li>Non-strict</li>
<li>Statically typed</li>
<li>Call-by-need</li>
<li>Whitespace-sensitive syntax</li>
<li>Memory managed using garbage collector</li>
<li>Naming conventions</li>
</ul>
<h2 id="purely-functional-programming-language"><span class="header-section-number">1.1</span> Purely functional programming language</h2>
<ul>
<li>Functional
<ul>
<li>Functions are first-class objects</li>
<li>Effectively values that can be passed around</li>
</ul></li>
<li>Pure
<ul>
<li>Haskell functions more closely resemble mathematical functions</li>
<li>Given any input value, they return the same output</li>
<li>This is <em>referential transparency</em></li>
<li>Typically operate on immutable data</li>
<li>No side effects</li>
<li>Referential transparency means that the compiler is free to do all kinds of optimization such as interleaving and inlining etc. which typically require additional annotations or data flow analysis in compilers for languages such as C++ and Java</li>
</ul></li>
</ul>
<h2 id="non-strictness"><span class="header-section-number">1.2</span> Non-strictness</h2>
<ul>
<li>Function arguments not evaluated unless they're actually used</li>
<li>A strict function is one which always evaluates all of its arguments</li>
<li>Non-strictness allows lazy evaluation</li>
<li>Haskell has annotations for strict evaluation where necessary</li>
<li>Lazy evaluation allows control structures to be built from user-defined functions</li>
</ul>
<h2 id="static-typing"><span class="header-section-number">1.3</span> Static typing</h2>
<ul>
<li>Catch many kinds of programmer error at <em>compile time</em></li>
<li>Expressive type system allows programmer lots of power and flexibility</li>
</ul>
<div class="figure">
<img src="images/region-of-abysmal-pain.png" alt="Simon Peyton Jones Region of Abysmal Pain Venn diagram" />
<p class="caption">Simon Peyton Jones Region of Abysmal Pain Venn diagram</p>
</div>
<h2 id="call-by-need"><span class="header-section-number">1.4</span> Call-by-need</h2>
<ul>
<li>Effectively call-by-name with memoization</li>
<li><em>If a function is evaluated</em> its value is stored for future uses</li>
</ul>
<h2 id="whitespace-sensitive-syntax"><span class="header-section-number">1.5</span> Whitespace-sensitive syntax</h2>
<ul>
<li>Like Python, Haskell is an <a href="https://en.wikipedia.org/wiki/Off-side_rule">off-side rule language</a></li>
<li>Most of the time the required indentation is what feels right</li>
</ul>
<h2 id="garbage-collection"><span class="header-section-number">1.6</span> Garbage collection</h2>
<ul>
<li>Haskell computations can produce a lot of memory garbage</li>
<li>Partly a consequence of non-strict evaluation which involves accumulation of <em>thunks</em> in memory</li>
<li>Also, partly a result of immutability</li>
<li>However, the GHC runtime's GC is highly tuned for this behaviour</li>
<li>Manual management of external resources such as externally allocated memory or resource handles is possible</li>
</ul>
<h2 id="naming-conventions"><span class="header-section-number">1.7</span> Naming conventions</h2>
<ul>
<li>Values and type variables start with initial lower-case letter</li>
<li>Types and type classes start with initial capital letter</li>
<li>Names typically employ medial capitalization, e.g. <code>MyType</code> and <code>myFunction</code> instead of <code>My_Type</code> and <code>my_function</code>, though this is not enforced</li>
<li>Punctuation such as <code>'</code> allowed</li>
<li>Some common, but not mandatory, suffixes exist including <code>M</code> and <code>M_</code> etc., e.g. <code>foldM</code>, <code>mapM</code> and <code>forM_</code></li>
<li>Operators are no different from functions except their names are spelt with symbol characters and can be used infix</li>
<li>Backticks can be used to use regular functions infix while parentheses can be employed to use operators in function-style prefix position</li>
<li>Type and data constructors are separate namespaces and can, therefore, share names</li>
<li>It is not uncommon to see type constructors with identically named data constructors, which we'll see later</li>
</ul>
<h2 id="what-else"><span class="header-section-number">1.8</span> What else?</h2>
<ul>
<li>Haskell has a clean, minimal syntax</li>
<li>Much of this is a consequence of some of these other characteristics</li>
<li>Example: non-strict evaluation allows us to <em>build</em> certain flow control constructs where other languages require language-level syntax</li>
<li>To a first approximation, Haskell programs consist of two elements:
<ul>
<li>Definitions</li>
<li>Expressions</li>
</ul></li>
<li>Nontrivial Haskell programs will also likely include some extras:
<ul>
<li>Type annotations</li>
<li>Pragmas</li>
<li>Import statements</li>
</ul></li>
</ul>
<h1 id="our-first-haskell-code"><span class="header-section-number">2</span> Our first Haskell code</h1>
<h2 id="interactive-haskell"><span class="header-section-number">2.1</span> Interactive Haskell</h2>
<p>First you'll need to start your terminal or command prompt. Once you've done that, we'll create a brand-new Stack project named <code>hello-world</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">stack</span> new hello-world simple --resolver=lts-7.8
<span class="kw">cd</span> hello-world</code></pre></div>
<p>The <code>simple</code> template is one of the simplest-possible Haskell projects: a project with a single executable target with the same name as the project itself, i.e. <code>hello-world</code> in this case. It consists of the following:</p>
<ul>
<li><code>LICENSE</code>: a licence file (BSD-compatible, by default)</li>
<li><code>Setup.hs</code>: a Haskell program used to pull in and build external project dependencies such as native libraries etc.</li>
<li><code>hello-world.cabal</code>: the Cabal file, which is akin to a project file in Visual Studio etc.: this defines various metadata for the project including an <code>executable</code> target</li>
<li><code>src/Main.hs</code>: a simple starter source file</li>
<li><code>stack.yaml</code>: a Stack-specific configuration file</li>
</ul>
<p>Next we'll start up GHCi, the interactive Haskell interpreter:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">stack</span> ghci</code></pre></div>
<ul>
<li>GHC is the Glasgow Haskell Compiler</li>
<li>GHCi is GHC <em>Interactive</em></li>
<li>It's GHC's read-evaluate-print-loop (REPL)</li>
<li>I've configured my prompt to display <code>λ&gt;</code> but the default is likely to be <code>Prelude&gt;</code> or <code>Main&gt;</code></li>
<li>Let's assign some values and evaluate some <em>expressions</em></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">Input</th>
<th align="left">Output</th>
<th align="left">Comment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>λ&gt; x = 5</code></td>
<td align="left"></td>
<td align="left">Assigns name <code>x</code> to value <code>5</code></td>
</tr>
<tr class="even">
<td align="left"><code>λ&gt; y = 6</code></td>
<td align="left"></td>
<td align="left">Assigns name <code>y</code> to value <code>6</code></td>
</tr>
<tr class="odd">
<td align="left"><code>λ&gt; z = x + y</code></td>
<td align="left"></td>
<td align="left">Assigns name <code>z</code> to value <code>x + y</code></td>
</tr>
<tr class="even">
<td align="left"><code>λ&gt; z</code></td>
<td align="left"><code>11</code></td>
<td align="left">Evaluates <code>z</code> and displays value</td>
</tr>
<tr class="odd">
<td align="left"><code>λ&gt; :type z</code><br>or<br><code>λ&gt; :t z</code></td>
<td align="left"><code>z :: Num a =&gt; a</code></td>
<td align="left">Shows type of <code>z</code></td>
</tr>
<tr class="even">
<td align="left"><code>λ&gt; :t 5</code></td>
<td align="left"><code>5 :: Num t =&gt; t</code></td>
<td align="left">Shows type of <code>5</code></td>
</tr>
<tr class="odd">
<td align="left"><code>λ&gt; z = &quot;hello&quot;</code></td>
<td align="left"></td>
<td align="left">Assigns name <code>z</code> to value <code>&quot;hello&quot;</code></td>
</tr>
<tr class="even">
<td align="left"><code>λ&gt; z</code></td>
<td align="left"><code>&quot;hello&quot;</code></td>
<td align="left">Evaluates <code>z</code> and displays value</td>
</tr>
<tr class="odd">
<td align="left"><code>λ&gt; :t z</code></td>
<td align="left"><code>z :: [Char]</code></td>
<td align="left">Shows type of <code>z</code></td>
</tr>
<tr class="even">
<td align="left"><code>λ&gt; :t (+)</code></td>
<td align="left"><code>(+) :: Num a =&gt; a -&gt; a -&gt; a</code></td>
<td align="left">Shows type of <code>+</code> operator</td>
</tr>
<tr class="odd">
<td align="left"><code>λ&gt; :q</code></td>
<td align="left"></td>
<td align="left">Quits GHCi session</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ul>
<li>We say &quot;assigns name <code>foo</code> to <code>bar</code>&quot; as opposed to &quot;assigns value <code>bar</code> to <code>foo</code>&quot;
<ul>
<li>In imperative programming languages <code>=</code> or equivalent operators typically perform <em>assignment</em> and the different values can be assigned to existing names from time to time</li>
<li>In Haskell, the name <code>foo</code> is <em>defined to be</em> the <code>value</code> in the equational sense of <code>=</code>: it's a definition and this is at the root of <a href="http://www.haskellforall.com/2013/12/equational-reasoning.html">equational reasoning</a></li>
</ul></li>
<li>In the absence of type annotations—which we'll cover later—GHCi will typically assign the most general type possible to an expression, subject to certain rules</li>
<li>GHCi will assign exactly one type to a given expression</li>
<li>Despite the absence of explicit type annotations in this example, the expressions are still strongly and statically typed</li>
<li>Type signatures consist of:
<ul>
<li>Optional: one or more constraints to the left of <code>=&gt;</code> (<a href="https://wiki.haskell.org/Pronunciation">pronounced</a> &quot;implies&quot;)</li>
<li>Types and <a href="https://www.haskell.org/tutorial/classes.html"><em>type classes</em></a> always spelt with initial upper-case letter</li>
<li>Type variables always spelt with initial lower-case letter</li>
<li>One or more types separated by <code>-&gt;</code> (pronounced &quot;to&quot;)</li>
<li>We haven't seen any <code>-&gt;</code> yet, but we will soon</li>
</ul></li>
<li><code>Num a</code> is the type class <code>Num</code> with one type variable <code>a</code>: more on this later</li>
</ul>
<h2 id="your-first-haskell-source-file"><span class="header-section-number">2.2</span> Your first Haskell source file</h2>
<p>Now we'll create a source file and write similar code. We'll then run this through a compiler and execute it. In your favourite editor, open a new file <code>Hello.hs</code> in the existing <code>hello-world</code> project directory and type the following text into it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dv">5</span>
y <span class="fu">=</span> <span class="dv">6</span>
z <span class="fu">=</span> x <span class="fu">+</span> y

main <span class="fu">=</span> print z</code></pre></div>
<ul>
<li>Most things you type into GHCi are valid lines of code in a Haskell source file</li>
<li>In order to be able to run a program, a Haskell program must have exactly one function named <code>main</code> in the <code>Main</code> module (or unnamed module) and must have an <code>IO</code> type</li>
<li><code>print</code> is a function that takes as an argument any value that has an instance of the <code>Show</code> type class: we'll talk about type classes more later</li>
</ul>
<p>Now we can run the program as follows:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">stack</span> runhaskell Hello.hs</code></pre></div>
<p>Now we'll change <code>Hello.hs</code> to the following to mimic our GHCi example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dv">5</span>
y <span class="fu">=</span> <span class="dv">6</span>
z <span class="fu">=</span> x <span class="fu">+</span> y
z <span class="fu">=</span> <span class="st">&quot;hello&quot;</span>

main <span class="fu">=</span> print z</code></pre></div>
<p>And we'll try to run it again:</p>
<pre class="console"><code>&gt; stack runhaskell Hello.hs

Hello.hs:4:1: error:
    Multiple declarations of ‘z’
    Declared at: Hello.hs:3:1
                 Hello.hs:4:1</code></pre>
<h2 id="differences-between-ghc-and-ghci"><span class="header-section-number">2.3</span> Differences between GHC and GHCi</h2>
<p>There are naturally many differences between the interactive and non-interactive Haskell environments. The most important ones for our immediate purposes are:</p>
<ul>
<li>Names can be <em>shadowed</em> in GHCi: i.e. we can introduce a new <code>z</code> that <em>hides</em> the previous definition with name <code>z</code></li>
<li>In Haskell source files, a top-level name can be used exactly once</li>
<li>Shadowing is allowed within Haskell source files, specifically within nested lexical scopes</li>
<li>In fact, that is exactly what's happening in GHCi: each line entered at the prompt is effectively a new lexical scope nested within the previous lexical scope</li>
</ul>
<h1 id="a-more-realistic-example"><span class="header-section-number">3</span> A more realistic example</h1>
<p><em>[Sources: <a href="https://www.haskell.org/tutorial/numbers.html">1</a>]</em></p>
<ul>
<li>Let's add some type annotations</li>
<li>Start up GHCi again</li>
</ul>
<pre class="ghci"><code>λ&gt; x :: Integer; x = 5
λ&gt; y :: Integer; y = 6
λ&gt; z :: Integer; z = x + y
λ&gt; z
11
λ&gt; :t x
x :: Integer
λ&gt; :t y
y :: Integer
λ&gt; :t z
z :: Integer
λ&gt; a = 5
λ&gt; :t a
a :: Num t =&gt; t</code></pre>
<ul>
<li>Let's do that in our source file:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> <span class="dt">Integer</span>
x <span class="fu">=</span> <span class="dv">5</span>

<span class="ot">y ::</span> <span class="dt">Integer</span>
y <span class="fu">=</span> <span class="dv">6</span>

<span class="ot">z ::</span> <span class="dt">Integer</span>
z <span class="fu">=</span> x <span class="fu">+</span> y

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print z</code></pre></div>
<ul>
<li>Consider the type of <code>a</code>:
<ul>
<li>Lower-case <code>t</code> is a <em>type variable</em> and can be any type that fulfils the type constraints</li>
<li><code>Num t</code> constrains <code>t</code> to be an instance of the <code>Num</code> type class</li>
<li><code>Num</code> has instances for (or &quot;is implemented by&quot;) all primitive numeric types in Haskell</li>
</ul></li>
<li>Consider the type of <code>x</code>, <code>y</code> and <code>z</code>:
<ul>
<li>These have no <code>=&gt;</code> and, therefore, no type constraints</li>
<li>Upper-case <code>Integer</code> is a <em>concrete type</em> corresponding to arbitrary-precision integers: this is an <em>instance</em> of <code>Num</code></li>
</ul></li>
<li>We'll talk about <code>IO ()</code> next lesson</li>
</ul>
<h2 id="when-to-use-type-annotations"><span class="header-section-number">3.1</span> When to use type annotations</h2>
<ul>
<li>Haskell has powerful type inference</li>
<li>Haskell designed in such a way that usually you won't need them</li>
<li>Sometimes ambiguities arise</li>
<li>Some more <a href="https://wiki.haskell.org/Dependent_type">advanced language features</a> make ambiguities more likely</li>
<li>Even so, type annotations are useful as documentation and for type-driven development</li>
<li>Most experienced Haskell developers recommend that all <em>top-level</em> definitions should carry a type annotation</li>
</ul>
<hr/>
<footer style="font-size: small; text-align: right;">
  Copyright &copy; 2016, Richard Cook<br/>
  <a href="https://github.com/rcook/beginning-practical-haskell/">Source code on GitHub</a>
</footer>
</body>
</html>
